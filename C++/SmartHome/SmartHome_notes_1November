1. change queue class to template
2. add semaphore to queue
3. add possibility to limit queue to certain size
4. add "explicit" to queue constructor. if there is one argument add explicit.
before every construcotr use explicit.
5. everything possible add to initilization list
6. only throw objects that are instances of classes that inherit from std::exception... has function called what()
7. better to throw MyExc("Failed...") instead of throw(const MyException&)
8. after - new Person - do :: if (!p1->isValid() throw BadPerson)
9. "Effective C++" third edition on disk on key
10. "More effective C++" disk on key
11. not allowed to throw from destructor. if needed then do try and catch within destructor
12. order of multiple catches for a single try should be first derived and then base. catch(...) should be last.
13. problems with exceptions. lock mutex then exception ... new, new then exception (memory leak)
If a function follows one of these three rules, then functioin is exception safe:
A. Basic guarantee - will never leave "illegal" situation (2nd new fails... or mutex locked) 
another example is scale of triangle which throw in middle of scaling then tri is not tri anymore.
B. Strong guarantee - either success or dont touch (transaction = operation happens entirely or doesnt happen at all.
C. No-Throw guarantee


